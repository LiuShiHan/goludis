User: package cache

import (
	"errors"
	"github.com/tidwall/assert"
	"github.com/tidwall/btree"
	"sync"
	"time"
)

type KEY interface {
	~string | ~int
}

type BucketCache[K KEY, V any] struct {
	shardN  uint64
	buckets []*bucket[K, V]
	hasher  Hasher[K]
	flushes int
}

type bucket[K KEY, V any] struct {
	mu       sync.RWMutex
	timerMu  sync.Mutex
	keys     *btree.BTreeG[dbItem[K, V]]
	exps     *btree.BTreeG[dbItem[K, V]]
	db       *BucketCache[K, V]
	timer    *time.Timer
	listMap  map[K]*listNode[V]
	listChan map[K]*listBroadcast
}

type listNode[V any] struct {
	val  V
	next *listNode[V]
	len  int
}

type listBroadcast struct {
	mu   sync.Mutex
	subs map[chan int]struct{}
	//order []chan int
}

func (b *listBroadcast) sub() chan int {
	b.mu.Lock()
	defer b.mu.Unlock()
	ch := make(chan int)
	b.subs[ch] = struct{}{}
	return ch
}

func (b *listBroadcast) pub(v int) {
	b.mu.Lock()
	defer b.mu.Unlock()
	for ch := range b.subs {
		select {
		case ch <- v:
		default:
		}
	}
}

func (b *listBroadcast) unsub(ch chan int) {
	b.mu.Lock()
	defer b.mu.Unlock()
	delete(b.subs, ch)
}

func (b *bucket[K, V]) scheduleTimerLocked() {
	minKey, ok := b.exps.Min()
	if !ok {
		b.stopTime()
		return
	}

	next := time.Until(minKey.opts.exat)
	if next < 0 {
		b.stopTime()
		go b.evictExpired()
		return
	}
	b.resetTimer(next)
}

// dd
func (b *bucket[K, V]) resetTimer(d time.Duration) {
	b.timerMu.Lock()
	defer b.timerMu.Unlock()
	if b.timer != nil {
		b.timer.Reset(d)
	} else {
		b.timer = time.AfterFunc(d, b.onTime)
	}
}

func (b *bucket[K, V]) onTime() {

	b.evictExpired()
}

func (b *bucket[K, V]) delete(key K) {
	b.mu.Lock()
	defer b.mu.Unlock()

	val, ok := b.keys.Delete(dbItem[K, V]{key: key})
	if ok == false {
		return
	}
	if val.opts != nil && val.opts.expires {
		b.exps.Delete(val)
	}

}

func (b *bucket[K, V]) evictExpired() {
	defer b.scheduleTimerLocked()
	now := time.Now()
	for {
		minKey, ok := b.exps.Min()
		if !ok || now.Before(minKey.opts.exat) {
			break
		}
		b.delete(minKey.key)
	}
}

func (b *bucket[K, V]) stopTime() {
	b.timerMu.Lock()
	defer b.timerMu.Unlock()
	if b.timer != nil {
		b.timer.Stop()
		b.timer = nil
	}
}

type dbItemOpts struct {
	expires bool
	exat    time.Time
}

type SetOptions struct {
	Expires bool
	TTL     time.Duration
}

type dbItem[K KEY, V any] struct {
	key     K
	val     V
	opts    *dbItemOpts
	keyless bool
}

func (db *BucketCache[K, V]) Set(key K, val V, opts *SetOptions) error {
	//index :=db.hasher.Hash(key)
	item := &dbItem[K, V]{key: key, val: val}
	if opts != nil {
		if opts.Expires {
			// The caller is requesting that this item expires. Convert the
			// TTL to an absolute time and bind it to the item.
			item.opts = &dbItemOpts{expires: true, exat: time.Now().Add(opts.TTL)}
		}

	}
	index := db.hasher.Hash(key) % db.shardN
	shard := db.buckets[index]
	err := shard.set(*item)
	return err

}

func (db *BucketCache[K, V]) Delete(key K) error {
	index := db.hasher.Hash(key) % db.shardN
	shard := db.buckets[index]
	shard.delete(key)
	return nil
}

func (db *BucketCache[K, V]) Get(key K) (val V, err error) {
	index := db.hasher.Hash(key) % db.shardN
	shard := db.buckets[index]
	dbItem, err := shard.get(key)
	if err != nil {
		var zero V
		return zero, err
	}
	return dbItem.val, nil
}

func (db *BucketCache[K, V]) LPush(key K, val V) {
	idx := db.hasher.Hash(key) % db.shardN
	bucket := db.buckets[idx]
	bucket.mu.Lock()
	defer bucket.mu.Unlock()
	head := bucket.listMap[key]
	bucket.listMap[key] = &listNode[V]{val: val, next: head}
	if _, ok := bucket.listChan[key]; ok {
		bucket.listChan[key].pub(1)
	} else {
		bucket.listChan[key] = &listBroadcast{}
	}
}

func (db *BucketCache[K, V]) BRPop(key K, timeout time.Duration) (val V, err error) {
	idx := db.hasher.Hash(key) % db.shardN
	bucket := db.buckets[idx]
	bucket.mu.Lock()
	head := bucket.listMap[key]
	if head != nil {
		bucket.listMap[key] = head.next
		if head.next == nil {
			delete(bucket.listMap, key)
		}
		bucket.mu.Unlock()
		return head.val, nil
	}
	var zero V
	bc, ok := bucket.listChan[key]
	if !ok {
		bc = &listBroadcast{subs: map[chan int]struct{}{}}
		bucket.listChan[key] = bc
	}
	ch := bc.sub()
	bucket.mu.Unlock()

	for {

		select {
		case <-ch:
			bucket.mu.Lock()
			head = bucket.listMap[key]
			if head != nil {
				bucket.listMap[key] = head.next
				if head.next == nil {
					delete(bucket.listMap, key)
				}
				bucket.mu.Unlock()

				bc.unsub(ch)
				return head.val, nil
			}
			bucket.mu.Unlock()

		case <-time.After(timeout):
			bc.unsub(ch)
			close(ch)
			return zero, errors.New("timeout")

		}

	}

}

func (sharDb *bucket[K, V]) set(item dbItem[K, V]) error {
	sharDb.mu.Lock()
	defer sharDb.mu.Unlock()
	sharDb.keys.Set(item)
	if item.opts != nil {

		sharDb.exps.Set(item)
		minKey, ok := sharDb.exps.Min()
		if ok {
			if !lessTimeFunc(minKey, item) {
				sharDb.scheduleTimerLocked()
			}
		} else {
			sharDb.scheduleTimerLocked()
		}

	}
	return nil
}

func (sharDb *bucket[K, V]) get(key K) (dbItem[K, V], error) {
	sharDb.mu.RLock()
	defer sharDb.mu.RUnlock()
	item, ok := sharDb.keys.Get(dbItem[K, V]{key: key})
	if ok {
		return item, nil
	} else {
		return dbItem[K, V]{key: key}, errors.New("not found")
	}
}

func defaultHasher[K KEY]() Hasher[K] {
	var zero K
	switch any(zero).(type) {
	case string:
		return any(strHasher{}).(Hasher[K])
	case int:
		return any(intHasher{}).(Hasher[K])
	default:
		panic("no default Hasher for this key type; use NewCacheWithHasher")
	}
}

func lessFunc[K KEY, V any](a, b dbItem[K, V]) bool {
	return a.key < b.key
}

func lessTimeFunc[K KEY, V any](a, b dbItem[K, V]) bool {
	assert.Assert(a.opts != nil && b.opts != nil && a.opts.expires && b.opts.expires)
	return a.opts.exat.Before(b.opts.exat)
}

func NewCache[K KEY, V any](shardBits int) (*BucketCache[K, V], error) {
	if shardBits < 0 || shardBits > 8 {
		return nil, errors.New("shardBits should in [0,8]")
	}
	shardNum := 1 << shardBits
	buctetCache := &BucketCache[K, V]{
		buckets: make([]*bucket[K, V], shardNum),
		hasher:  defaultHasher[K](),
		shardN:  uint64(shardNum),
	}

	for i := 0; i < shardNum; i++ {
		buctetCache.buckets[i] = &bucket[K, V]{
			mu:       sync.RWMutex{},
			keys:     btree.NewBTreeG(lessFunc[K, V]),
			exps:     btree.NewBTreeG(lessTimeFunc[K, V]),
			db:       buctetCache,
			listMap:  make(map[K]*listNode[V]),
			listChan: make(map[K]*listBroadcast),
		}
	}

	return buctetCache, nil
}

func (db *BucketCache[K, V]) Close() error {
	for _, bucket := range db.buckets {
		bucket.stopTime()
	}
	return nil
} 这是我写的一个缓存代码，现在我想让他可以通过redis客户端来调用，请问怎么写
Kimi: 要让 Redis 客户端（如 `redis-cli` 或任何 Redis SDK）可以调用你这套 Go 实现的缓存系统，你需要在两者之间加一层 **Redis 协议兼容的网关层**。这个网关层负责：

1. **监听 Redis 协议端口**（默认 6379）。
2. **解析 Redis 协议命令**（如 `GET`, `SET`, `LPUSH`, `BRPOP` 等）。
3. **将命令映射到你缓存系统的方法调用**。
4. **将结果编码为 Redis 协议格式返回**。

---

### ✅ 最简单方案：使用 [go-redis-server](https://github.com/tidwall/redcon)（轻量级 Redis 协议实现）

Redis 协议是文本协议，你可以用 [redcon](https://github.com/tidwall/redcon)（由 tidwall 写的轻量级 Redis 协议框架）快速实现兼容层。

---

### ✅ 步骤一：引入 redcon

```bash
go get github.com/tidwall/redcon
```

---

### ✅ 步骤二：写一个适配器

```go
package main

import (
	"context"
	"errors"
	"fmt"
	"log"
	"strconv"
	"strings"
	"time"

	"github.com/tidwall/redcon"
	"yourmodule/cache" // 替换成你的模块路径
)

var db *cache.BucketCache[string, string]

// 启动 Redis 协议服务器
func main() {
	var err error
	db, err = cache.NewCache[string, string](4)
	if err != nil {
		log.Fatal(err)
	}

	addr := ":6379"
	log.Println("Starting Redis-compatible server on", addr)
	err = redcon.ListenAndServe(addr,
		handleRedisCommand,
		func(conn redcon.Conn) bool { return true },
		func(conn redcon.Conn, err error) { log.Println("closed:", err) },
	)
	if err != nil {
		log.Fatal(err)
	}
}

func handleRedisCommand(conn redcon.Conn, cmd redcon.Command) {
	switch strings.ToUpper(string(cmd.Args[0])) {
	case "SET":
		if len(cmd.Args) != 3 && len(cmd.Args) != 5 {
			conn.WriteError("ERR wrong number of arguments for 'set' command")
			return
		}
		key := string(cmd.Args[1])
		val := string(cmd.Args[2])
		var opts *cache.SetOptions
		if len(cmd.Args) == 5 && strings.ToUpper(string(cmd.Args[3])) == "EX" {
			ttlSec, err := strconv.Atoi(string(cmd.Args[4]))
			if err != nil {
				conn.WriteError("ERR invalid expire time")
				return
			}
			opts = &cache.SetOptions{
				Expires: true,
				TTL:     time.Duration(ttlSec) * time.Second,
			}
		}
		_ = db.Set(key, val, opts)
		conn.WriteString("OK")

	case "GET":
		if len(cmd.Args) != 2 {
			conn.WriteError("ERR wrong number of arguments for 'get' command")
			return
		}
		val, err := db.Get(string(cmd.Args[1]))
		if err != nil {
			conn.WriteNull()
		} else {
			conn.WriteBulkString(val)
		}

	case "LPUSH":
		if len(cmd.Args) < 3 {
			conn.WriteError("ERR wrong number of arguments for 'lpush' command")
			return
		}
		key := string(cmd.Args[1])
		for i := 2; i < len(cmd.Args); i++ {
			db.LPush(key, string(cmd.Args[i]))
		}
		conn.WriteInt(len(cmd.Args) - 2)

	case "BRPOP":
		if len(cmd.Args) != 3 {
			conn.WriteError("ERR wrong number of arguments for 'brpop' command")
			return
		}
		key := string(cmd.Args[1])
		timeoutSec, err := strconv.Atoi(string(cmd.Args[2]))
		if err != nil {
			conn.WriteError("ERR invalid timeout")
			return
		}
		val, err := db.BRPop(key, time.Duration(timeoutSec)*time.Second)
		if err != nil {
			conn.WriteNull()
		} else {
			conn.WriteArray(2)
			conn.WriteBulkString(key)
			conn.WriteBulkString(val)
		}

	default:
		conn.WriteError(fmt.Sprintf("ERR unknown command '%s'", string(cmd.Args[0])))
	}
}
```

---

### ✅ 步骤三：启动服务器并测试

```bash
go run main.go
```

然后用 `redis-cli` 测试：

```bash
redis-cli -p 6379
127.0.0.1:6379> set foo bar
OK
127.0.0.1:6379> get foo
"bar"
127.0.0.1:6379> lpush mylist a b c
(integer) 3
127.0.0.1:6379> brpop mylist 1
1) "mylist"
2) "c"
```

---

### ✅ 注意事项

| Redis 命令 | 你的实现兼容情况 |
|------------|------------------|
| `SET key value [EX]` | ✅ 支持 |
| `GET key` | ✅ 支持 |
| `LPUSH key val...` | ✅ 支持 |
| `BRPOP key timeout` | ✅ 支持 |
| `DEL`, `EXISTS`, `TTL` 等 | ❌ 需要你扩展 `handleRedisCommand` |

---

### ✅ 总结

你只需要：

- 用 `redcon` 实现 Redis 协议解析。
- 把命令映射到你缓存的 `Set/Get/LPush/BRPop` 等方法。
- 启动监听端口，即可让 Redis 客户端无缝调用。

如你后续还想支持 `HMSET`, `ZADD`, `PUB/SUB` 等命令，继续扩展 `handleRedisCommand` 即可。




点击链接查看和 Kimi 的对话 https://www.kimi.com/share/d2q3u0lnfo2n6uugdv10